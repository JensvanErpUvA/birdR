#' @title track_density_rast
#'
#' @description count number of points per grid cell
#'
#' @param data spatvector object (points)
#' @param resolution resolution
#' @param crs summary function
#' @param e minimum x value of extent in lonlat
#'
#' @return a raster with counts per grid cell
#'
#' @export
#'
#' @examples
#'
#'
#' \dontrun{
#' r <- track_density_rast(data, resolution=500)
#' }
#'
track_density_rast <- function(data=trajectories,crs=loc_proj, e=NULL,resolution) {

  # make sure it is a spatraster
  if(class(data)[1] != 'SpatVector'){
    data <- vect(data)
  }

  input_crs <- terra::crs(data)

  if(is.null(e)){
    # CREATE A RASTER WITH EXTENT OF THE DATASET
    r <- terra::rast(terra::ext(data),crs=input_crs)
  }
  if(class(e)[1] == 'SpatExtent'){
    r <- rast(e,crs=input_crs)
  }
  if(class(e) == 'numeric'){
    r <- rast(crs=input_crs)
    terra::ext(r) <- e
  }

  # convert to local projection to measure resolution in meters
  if(!is.null(crs)){
    r <- terra::project(r,crs)
    terra::res(r) <- resolution
    # reproject back to original projection
    r <- terra::project(r,input_crs)
  }

## fill in number of raster cells
numcells <- 1:(dim(r)[1] * dim(r)[2])
values(r) <- numcells

## create dataframe with coordinates of extent raster
r_df <- terra::as.data.frame(r, xy=TRUE)

## count the number of tracks intersecting with each cell
r_count <- as.data.table(extract(r, data, xy=TRUE))
r_count[,cell_num:=1/length(lyr.1), by=ID]
r_count[,freq:=sum(cell_num), by=lyr.1]
r_count[,c("ID","cell_num"):=NULL]
r_count <- unique(r_count, by="lyr.1") %>%
  left_join(x=r_df, by="lyr.1")

## if there are zero tracks -> make cell 0
r_count[which(is.na(r_count$freq)),"freq"] <- 0
values(r) <- r_count$freq
NAflag(r) <- 0
set.names(r,"tracks")

#project(r, wgs84_proj)
## Return the raster
return(r)
}

#' @title rastgam
#'
#' @description count number of points per grid cell
#'
#' @param track_raster spatraster generated by track_density_rast
#' @param radar radar location
#' @param distance default mid mad
#'
#' @return a raster with counts per grid cell
#'
#'
#' @examples
#'
#'
#' \dontrun{
#' r <- rastgam(data, resolution=500)
#' }
#'
rastgam <- function(track_raster,radar, distance=c(mid,mad)){
  ## Create a layer of distance from the cell to the radar
  dist_rast <- terra::distance(track_raster,vect(radar))
  #dist_rast <- project(dist_rast, wgs84_proj)
  set.names(dist_rast,"distance")

  add(track_raster) <- dist_rast

  rast_data <- as.data.table(terra::as.data.frame(track_raster,xy=TRUE))
  setnames(rast_data, c("x","y"), c("lon","lat"))

  gam_stats <- rast_data[distance>=min(distance) & distance<=max(distance),]
  gam_distbias <- gam(tracks ~ s(distance),
                      data=gam_stats)

  dummy_dist <- seq(min(distance),max(distance),length.out = 1000)
  response_dist <- as.data.table(predict.gam(gam_distbias,
                                             data.frame(distance = dummy_dist),
                                             type = "response",
                                             se.fit = T))
  ## TODO get the confidence interval of the gam.prediction

  g <- ggplot()+
    geom_point(data = gam_stats, aes(x=distance,y=tracks))+
    geom_ribbon(aes(x=dummy_dist,ymin=(response_dist$fit-10*response_dist$se.fit),
                    ymax=(response_dist$fit+10*response_dist$se.fit)), colour = NA, fill = "purple", alpha = 0.4)+
    geom_line(aes(x=dummy_dist,y=response_dist$fit), colour = "purple", lwd=1)+
    theme_minimal()+
    theme(legend.text = element_text(size=15, face="bold"),
          legend.title = element_text(size=15, face="bold"),
          axis.title = element_text(size=20, face="bold"),
          axis.text = element_text(size=15, face="bold"))

  plotly::ggplotly(g)

  res <- list(gam_distbias, rast_data)
  names(res) <- c('GAM','DATA')
  return(res)
}


#' @title crosses_aoi
#'
#' @description count number of points per grid cell
#'
#' @param trajectory trajectory geometry
#' @param raster raster
#'
#' @return a raster with counts per grid cell
#'
#'
#' @examples
#'
#'
#' \dontrun{
#' r <- rastgam(data, resolution=500)
#' }
#'
crosses_aoi <- function(trajectory, raster) {
  ## convert track sf's to SpatVector
  traj_vect <- vect(st_zm(trajectory))

  ## Get the cells with which the trajectory overlaps
  overlap <- extract(raster, traj_vect, xy=TRUE)

  return(any(overlap$inclusion_cell==1))
}


#' @title distb
#'
#' @description correction for distance bias based on track raster
#'
#' @param x track dataset
#' @param track_raster spatraster generated by track_density_rast
#' @param radar radar location
#' @param distance default mid mad
#'
#' @return a raster with counts per grid cell
#'
#'
#' @examples
#'
#'
#' \dontrun{
#'
#' }
#'
distb <- function(x,track_raster,radar,distance=c(mid,mad)){

  crs_input <-terra::crs(track_raster)
  rastgam_output <- rastgam(track_raster=track_raster,radar=radar, distance=distance)
  gam_distbias <- rastgam_output[[1]]
  rast_data <- rastgam_output[[2]]

  rast_data[distance>=min(distance) & distance<=max(distance) & !is.na(tracks) , #
            threshold_tracks:=predict.gam(gam_distbias,distance=rast_data$distance,type="response")]
  rast_data[,inclusion_cell:=tracks>=threshold_tracks]
  rast_data[is.na(threshold_tracks),inclusion_cell:=T]

  fig_rast_data <- as.data.table(as.data.frame(mask(rast(rast_data, type="xyz", crs=crs_input),vect(area_of_inclusion)),xy=TRUE))
  setnames(fig_rast_data, c("x","y"), c("lon","lat"))

  ggplot()+
    geom_tile(data=fig_rast_data[inclusion_cell==TRUE,], aes(x=lon,y=lat,fill=tracks))+
    geom_sf(data=area_of_inclusion, fill=NA, colour="black", lwd = 0.3)+
    geom_sf(data=turbines[near_aoi==TRUE,geometry], colour="black", lwd = 0.1)+
    geom_sf(data=radar, colour="darkred", shape=16, lwd = 0.7)+
    scale_fill_gradient(low="grey", high="darkblue", name="Number\n of tracks", limits=c(0,max(fig_rast_data[inclusion_cell==T,tracks])))+
    labs(x="Longitude", y="Latitude", title=area_name)+
    theme_minimal()+
    theme(legend.text = element_text(size=15, face="bold"),
          legend.title = element_text(size=15, face="bold"),
          axis.title = element_text(size=20, face="bold"),
          axis.text = element_text(size=15, face="bold"))
  #ggplotly(g)

  setnames(rast_data, c("lon","lat"), c("x","y"))
  track_raster <- rast(rast_data, type="xyz", crs=crs_input)

  x[,crosses_raster:=sapply(trajectory,crosses_aoi,raster=track_raster)]

  return(x)
}



